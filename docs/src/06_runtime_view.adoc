ifndef::imagesdir[:imagesdir: ../images]

[[section-runtime-view]]
== Runtime View


=== <Runtime Scenario 1>


* _<insert runtime diagram or textual description of the scenario>_
* _<insert description of the notable aspects of the interactions between the
building block instances depicted in this diagram.>_

It is possible to use a sequence diagram:

[plantuml,"Sequence diagram",png]
----
actor Alice
actor Bob
database Pod as "Bob's Pod"
Alice -> Bob: Authentication Request
Bob --> Alice: Authentication Response
Alice  --> Pod: Store route
Alice -> Bob: Another authentication Request
Alice <-- Bob: another authentication Response
----

=== Runtime Scenario 2: Playthrough of a Game against a Bot

The following diagram shows the flow of a normal playthrough of a game against a bot (initialization, turns, and finalization):

[plantuml,"User VS Bot Game Diagram",png]
----
actor User
actor GUI
actor Backend
actor Bot
database Database as "Database"
== Initialization ==
User -> GUI: Navigate to Game Initialization
GUI -> Backend: Request for game against a Bot
Backend -> Bot: Initialize Bot
Bot --> Backend: Return Bot
Backend --> GUI: Game is initialized
GUI --> User: Render initialized Game
== Turns ==
loop Each turn until game ends
    User -> GUI: Perform move
    GUI -> Backend: Send user move
    Backend -> Bot: Request bot move
    Bot --> Backend: Bot move
    Backend --> GUI: Updated game state
    GUI --> User: Render updated game state
end
== Finalization ==
alt User wins
    Backend -> Database: Store game result (User victory)
    Backend --> GUI: Game finished (User wins)
    GUI --> User: Show victory screen
else Bot wins
    Backend -> Database: Store game result (Bot victory)
    Backend --> GUI: Game finished (Bot wins)
    GUI --> User: Show defeat screen
end
----

As such, a standard playthrough would be:

1. A user navigates to the game initialization
2. The backend initializes a bot that is returned, therefore initializing the game
3. The main loop of the game is initialized

Then the loop of the turns would be:

1. The user makes a move
2. The move is returned to the backend
3. A bot move is requested
4. The move of the bot is done and send to the GUI

It will continue until the game ends, and once that happens:

1. The result of the game is stored in the database (either user wins or user loses)
2. The backend sends a signal to the GUI with the result of the game
3. Depending on the result, either a victory or a defeated screen is shown (which could be the same screen with different information, but this is a design decision)
4. The bot is released  